<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Hello-Zyunee"><a href="#Hello-Zyunee" class="headerlink" title="Hello Zyunee"></a>Hello Zyunee</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C语言</title>
    <url>/2020/07/31/C%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>一、指针<br>·指针变量的值是指具有实际值的变量的地址<br>·作为参数的指针</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void f(int *p);</span><br><span class="line">int i;</span><br><span class="line">f(&amp;i);</span><br></pre></td></tr></table></figure>
<p>  在函数内可以通过这个指针访问外面的i（可访问地址上的变量），可读写，即可改变外部i的值<br>·函数通过指针返回时<br>  常用套路：让函数返回特殊的，不属于有效范围内的值来表示出错<br>当返回任何值都有效的话得分开返回，状态（放入if）由函数返回，值由指针参数返回<br>·0地址<br>  可用0地址表示特殊的事情：返回的指针无效、指针没有被真正初始化时可先初始化为0<br>  NULL是预定义符号，表示0地址<br>·指针与数组<br>  数组变量是特殊的指针（是const的指针，不能被赋值）<br>·指针与const<br>  ·const在星号之后<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int * const q=&amp;i;//q++不可</span><br></pre></td></tr></table></figure><br>  一旦指向某个变量，不能指向其他变量（指针本身不能修改）<br>  ·const在星号之前<br> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int  const *q=&amp;i;//*q=26不可</span><br></pre></td></tr></table></figure><br>  不能通过指针修改变量（所指的东西不可修改）<br>  当要传递的参数类型比地址大时，常用这种手段，既能用较少字节数传递给参数，又能避免函数对外面变量进行修改<br>·指针类型转换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int *p=&amp;i;</span><br><span class="line">void *q=(void *)p;</span><br></pre></td></tr></table></figure>
<p>  并没有改变p所指变量的类型，而是通过q的角度认为i是void<br>·动态内存分配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(int *)malloc(n *sizeof(int));//返回的结果为void *，需要类型转换为自己需要的类型</span><br></pre></td></tr></table></figure>
<p>  没空间（申请失败）会返回0或NULL<br>  free()必须是申请地址的首地址<br>·指针与结构<br>  用-&gt;表示指针所指的结构变量中的成员</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Struct date *p=&amp;myday;//(*p).month=12和p-&gt;month=12等价</span><br></pre></td></tr></table></figure>


<p>二、补码<br>·补码<br>  1111 1111(-1)+0000 0001(1)=1 0000 0000(0)<br>  溢出的1舍弃<br>  (1)0000 0000-0000 0001=1111 1111<br>·1111 1111被当作纯二进制看是255，做补码是-1<br>·对于-a,补码即为2^n-a,n是这种类型的位数<br>·数的范围<br>  1111 1111——1000 0000表示-1——-128<br>  0000 0001——0111 1111表示1——127<br>  Char 1字节 8bit -128——127<br>  Short 2字节 16bit -32768~32767<br>  Int （取决于编译器）-2^(32-1)——2^(32-1)-1<br>  Unsigned 指不以补码输出，表达范围扩大</p>
<p>三、位运算<br>·按位与&amp;<br>都为1才是1 否则0<br>  应用：让某一位或某些位为0<br>        取一个数中的一段<br>·按位或|<br>有1就是1 否则0<br>  应用：使一位或几个位为1<br>        把两个数拼起来<br>·按位取反~<br>  补码=取反+1<br>·按位异或^<br>  相等为0，不相等为1<br><label style="color:yellow">应用：多层异或加其他js算法用来防破解（？不懂）</label><br>·位段<br>  结构体中以位为单位来指定其成员所占内存长度，以位为单位的成员称为“位段”或者“位域”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">	unsigned int leading: 3;</span><br><span class="line">	unsigned int FLAG1: 1;</span><br><span class="line">	unsigned int FLAG2: 2;</span><br><span class="line">	int FLAG3: 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·举个栗子<br> 输出一个数的二进制//子网掩码原理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	int number;</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">	unsigned mask = 1u&lt;&lt;31;//最低位为1的unsigned</span><br><span class="line">	<span class="keyword">for</span>(;mask;mask&gt;&gt;=1)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,number&amp;mask?1:0);//循环后得到number的二进制</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、单向链表<br>·制作链表基本思路</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _node&#123;</span><br><span class="line">	int value;</span><br><span class="line">	struct _node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	Node *head=NULL;</span><br><span class="line">	int number;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		scanf(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">		<span class="keyword">if</span>(number!=-1)&#123;</span><br><span class="line">        //add to linked-list</span><br><span class="line">			Node *p=(Node *)malloc(sizeof(Node));</span><br><span class="line">			p-&gt;value = number;</span><br><span class="line">			p-&gt;next = NULL;</span><br><span class="line">        //find the last</span><br><span class="line">			Node *last = head;</span><br><span class="line">			<span class="keyword">if</span>(last)&#123;</span><br><span class="line">				<span class="keyword">while</span>(last-&gt;next)&#123;</span><br><span class="line">					last = last-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">           //attach</span><br><span class="line">				last-&gt;next = p;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				head = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(number!=-1);</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·优化<br> 1.制造一个全局变量 Node* head(不全面，有缺陷)<br> 2.构建函数add函数，返回一个指针head<br> 3.传入指针的指针 head=add(&amp;head,number)<br> 4.另构建一个结构放head (tail)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct _node&#123;</span><br><span class="line">	int value;</span><br><span class="line">	struct _node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">typedef struct _list&#123;</span><br><span class="line">    Node* head;</span><br><span class="line">&#125;List;</span><br><span class="line">void add(Node* head,int number);//链表的增加</span><br><span class="line">void <span class="built_in">printf</span>(List *pList);//链表的搜索</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	List list;</span><br><span class="line">    list.head=NULL;</span><br><span class="line">	int number;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		scanf(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line">		<span class="keyword">if</span>(number!=-1)&#123;</span><br><span class="line">        head = add(&amp;list,number);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(number!=-1);</span><br><span class="line">   //链表的删除</span><br><span class="line">   Node *p;</span><br><span class="line">   Node *q;</span><br><span class="line">   <span class="keyword">for</span>(q=NULL,p=list.head;p;q=p,p=p-&gt;next)&#123;</span><br><span class="line">   	  <span class="keyword">if</span>(p-&gt;value == number)&#123;</span><br><span class="line">         <span class="keyword">if</span>(q)&#123;</span><br><span class="line">            q-&gt;next=p-&gt;next;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list.head=p-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">         free(p);</span><br><span class="line">         <span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //链表的清除</span><br><span class="line">   <span class="keyword">for</span>(p=head;p;p=q)&#123;</span><br><span class="line">   	  q=p-&gt;next;</span><br><span class="line">   	  free(p);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">void add(List* plist,int number)</span><br><span class="line">&#123;</span><br><span class="line">   //add to linked-list</span><br><span class="line">	Node *p=(Node *)malloc(sizeof(Node));</span><br><span class="line">	p-&gt;value = number;</span><br><span class="line">	p-&gt;next = NULL;</span><br><span class="line">   //find the last</span><br><span class="line">	Node *last = pList-&gt;head;</span><br><span class="line">	<span class="keyword">if</span>(last)&#123;</span><br><span class="line">         <span class="keyword">while</span>(last-&gt;next)&#123;</span><br><span class="line">         last = last-&gt;next;</span><br><span class="line">		 &#125;</span><br><span class="line">       //attach</span><br><span class="line">		last-&gt;next = p;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		pList-&gt;head = p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">void <span class="built_in">printf</span>(List *pList)&#123;</span><br><span class="line">   Node *p;</span><br><span class="line">   <span class="keyword">for</span>( p=pList-&gt;head; p ;p=p-&gt;next)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,p-&gt;value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
